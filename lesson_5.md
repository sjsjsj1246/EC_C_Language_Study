# 5강

## 목차
- 함수
- 변수의 종류와 범위
- 제귀함수

## 함수

첫시간에 C언어는 함수 중심 프로그래밍(procedure-oriented-programming)(절차지향 프로그래밍 아님) 이라고 했습니다. 매번 사용한 main 함수도 함수이고 printf, scanf도 함수입니다. 그리고 우리가 필요한 동작을 함수로 만들어 볼 것입니다. 이렇듯 C언어 프로그램의 동작은 함수 위주로 돌아가는 것을 알 수 있습니다.  

### 함수의 선언, 정의

함수는 반환형식, 함수이름, 매개변수(또는 인자) 3가지를 통해 선언합니다.  

함수의 반환이란 함수의 내용을 실행하고 함수를 실행한 곳으로 값을 주는 것을 말합니다.  

```
반환형식 함수이름(인자, 인자...);
```
선언할 때는 인자의 타입만 적어주면 됩니다.

함수를 정의하는 방법은 중괄호를 통해 함수의 내용을 만들어 주면 됩니다.  
```
반환형식 함수이름(인자, 인자...)
{
    코드
}
```
정의할 때는 인자의 이름도 적어줘야 합니다.

예를 들어 다음과 같이 선언, 정의 할 수 있습니다.
```c
int sum(int, int);
int sum(int a, int b);
int sum(int a, int b)
{
    return a+b;
}
```
return 명령어를 통해 반환을 할 수 있습니다.

```c
#include<stdio.h>

int sum(int a, int b)
{
    return a+b;
}

int main()
{
    printf("%d", sum(1,3));
}
```
이렇게 사용할 수 있습니다.  

함수를 바로 정의해서 쓰면 되지 왜 선언을 하냐 하면 컴파일러의 컴파일 순서 때문인 것도 있고 한눈에 함수를 보기 쉽기 때문입니다.

```c
#include<stdio.h>

int main()
{
    printf("%d", sum(1,3));
}

int sum(int a, int b)
{
    return a+b;
}
```
컴파일러는 코드를 위에서 아래로 컴파일을 합니다. 컴파일러가 main의 sum을 처음 만날 때는 sum이라는 것이 선언, 정의가 되지 않은 상태라서 sum이 무엇인지 알수가 없습니다. 따라서 컴파일 에러를 냅니다. 따라서 sum함수를 위에 정의하던지 선언을 위에 한번 해주는 방식으로 해결할 수 있습니다.  
```c
#include<stdio.h>

int sum(int, int);

int main()
{
    printf("%d", sum(1,3));
}

int sum(int a, int b)
{
    return a+b;
}
```
이렇게 선언을 먼저 해놓으면 sum을 어디에 정의하든 컴파일러가 잘 해석할 수 있습니다.  
왜 굳이 이렇게 선언과 정의를 따로 나누는 방식을 사용해야 하는가 궁금하실 수 있습니다.  
함수를 한두개만 만들었다면 이런식으로 코드를 짜지 않아도 됩니다. 하지만 함수가 아주 많아지고 함수끼리 서로 호출하는 상황이 오면 a를 b보다 먼저 정의하고 c는 b보다 먼저 정의하고 등등 구조가 헷갈리고 불안정해지게 됩니다. 따라서 프로그램의 규모가 커졌을 때 함수의 선언을 한번에 쭉 해놓고 정의를 따로 적어놓는 것이 C언어 프로그램의 기본 코딩 스타일입니다.  

### 함수의 여러 형태

함수는 반환값과 인자가 없어도 됩니다. 함수의 반환값이 없을 때는 반환 형식을 void라 하고 인자가 없을 때는 void로 넣어도 되고 아무 것도 안써도 됩니다.  
```c
int sum(int a, int b);
int getValue();
void setValue(int a);
void printLogo();
```
함수의 형태는 사용자의 용도에 따라 선택하면 됩니다.

### 함수의 목적

함수는 첫번째로 코드의 재사용을 위해 만듭니다. 수를 뒤집어주는 알고리즘을 기억하나요. 이 알고리즘은 필요한 변수가 많아 여러번 사용하면 코드가 지저분해 집니다. 따라서 이 코드를 함수로 빼면 구조가 굉장히 단순해집니다. 수 뒤집기 문제를 푸는 코드를 통해 보여드리겠습니다.  
```c
#include<stdio.h>
int main()
{
    int t;
    scanf("%d", &t);
    while (t--)
    {
        int n;
        scanf("%d", &n);

        int rev_n = 0;
        int temp = n;
        while (temp > 0)
        {
            rev_n *= 10;
            rev_n += temp % 10;
            temp /= 10;
        }

        int sum = n + rev_n;

        int rev_sum = 0;
        temp = sum;
        while (temp > 0)
        {
            rev_sum *= 10;
            rev_sum += temp % 10;
            temp /= 10;
        }

        if (sum == rev_sum) printf("YES\n");
        else printf("NO\n");
    }
}
```

함수 활용
```c
#include <stdio.h>
int rev(int n)
{
    int res = 0;
    while (n > 0)
    {
        res = res * 10 + n % 10;
        n /= 10;
    }
    return res;
}

int main()
{
    int t;
    scanf("%d", &t);
    while (t--)
    {
        int n;
        scanf("%d", &n);
        int sum = n + rev(n);
        printf("%s\n", sum == rev(sum) ? "YES" : "NO");
    }
}
```
함수의 재사용성의 중요성이 돋보이는 코드입니다.  

함수를 사용하는 두번 째 이유는 제가 좀 느끼는 것인데, 프로그램의 동작을 주요 동작에 의해 함수로 나누어서 각각의 함수의 동작이 독립적이게 되면, 코딩을 할 때 신경써야 할 요소들이 각각의 함수에 분산되기 때문에 함수를 사용합니다.  
함수 공간에서 변수를 선언하고 인자를 받아 코드를 실행하고 값을 반환한 뒤 함수를 종료하면 함수의 변수들도 모두 소멸됩니다. 함수는 제 할 일을 하고 값을 반환한 뒤에 깔끔하게 모든 것이 소멸됩니다.  
이는 위 코드에서도 느낄 수 있습니다. main함수 입장에서는 수 뒤집기에 관한 코드를 신경쓸 필요가 없이 rev()함수를 잘 호출하고 값만 받으면 되고 rev()함수는 수를 뒤집는 알고리즘만 잘 작동하도록 신경쓰면 됩니다.  

rev 함수를 생성함으로써 코드를 재사용하여 변수의 갯수도 줄어들고 코드가 단순해집니다. 또한 코딩을 할 때 한번에 신경써야 할 것들이 분산돼서 코딩이 수월해집니다.  

### 함수를 만들 때 주의할 점

함수는 기본적으로 하나의 목적에 맞는 동작만 해야 합니다. 더하기를 해주는 함수 sum()을 만들었는데 이 함수가 더한 값을 출력까지 해준다고 생각해봅시다.  
```c
int sum(int a, int b)
{
    printf("%d + %d = %d\n", a, b, a+b);
    return a+b;
}
```
당시에 필요에 의해서 이런 식으로 함수를 짰을 수도 있지만 이런식으로 함수의 본 목적에 맞지 않는 명령이 섞이면 함수의 재사용성이 급격히 떨어집니다.  
더한 값만 얻어야 할 때 이 함수를 쓸 수 없고 출력하는 형식이 언제든 바뀔 수 있기 때문에 더한 값을 반환한다는 목적에 맞는 동작만 해야 합니다.  
```c
int sum(int a ,int b)
{
    return a+b;
}

int main()
{
    printf("%d + %d = %d\n", a, b, sum(a, b));
}
```

## 변수의 종류와 범위




## 재귀함수



