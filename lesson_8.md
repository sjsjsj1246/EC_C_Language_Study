# 8강

## 목차
- 좋은 코드 작성법
- GCC 안내

## 좋은 코드 작성법

### 클린코드(Clean Code)의 필요성

코드는 컴퓨터와 대화할 수 있는 수단이라고 했습니다. 하지만 코드는 프로그래머끼리 대화하는 수단이기도 합니다.  
여러분은 절대 혼자서 코딩을 하지 않습니다. 여러분의 코드를 여러분만이 보지 않습니다. 미래의 당신 또한 그 코드를 볼 것이기 때문입니다. 그것이 10분 뒤라 할지라도요  
여러분은 평소에도 좋은 코드를 작성하기 위해 연습해야 합니다. 나쁜 코드를 작성하는 습관이 생기면  자기 조차도 읽기도 싫은 코드가 만들어 질겁니다.  

### 좋은 코드란 무엇인가

- 논리적이며 헷갈리지 않고 잘 읽히는 코드  
- 단순하며 한번에 한가지의 작업에만 집중한다.  
- 중복이 적다.

#### 깨진 유리창 이론

깨진 유리창 이론을 들어보셨습니까? 깨진 유리창을 발견하면 사람이 살지 않는 곳, 방치되어 있는 곳이라는 생각을 하게 되어 나머지 멀쩡한 유리도 깨버리는 등의 범죄가 일어날 수 있다는 거죠. 전봇대에 누가 쓰레기 봉투 하나를 버리면 다른 사람들도 무심코 버리게 되는 것도 마찬가지 입니다.  
즉 사소해보이는 일들을 방치해둔다면 더 큰 결과로 확대되어 나타날 수 있다는 것입니다.  
이걸 왜 설명하느냐면 코드도 마찬가지로 잘못 작성한 코드를 방치하게 되면 그 코드와 연관된 코드까지 모두 엉켜서 프로그램의 구조가 엉망이 되기 쉽습니다.  

이 문제는 보이 스카우트 규칙을 적용하여 해결할 수 있습니다.  

#### 보이 스카우트 규칙 

보이 스카우트 규칙은 다음고 같습니다.
>
    Always leave the campground cleaner than you found it.
    언제나 처음 왔을 때보다 깨끗하게 해놓고 캠프장을 떠날 것.

이를 프로그래밍에 적용하면 코드를 볼 때마다 전보다 더 나은 상태로 만드는 것입니다. 변수의 이름을 바꾼다던지 중복되는 코드를 함수로 만든다던지 개선을 조금씩만 해도 훨씬 좋아질 것입니다.  

### 의미있는 이름 - 네이밍 방법

변수의 이름만 잘 지어줘도 절반은 했다고 볼 수 있습니다. 실제 코드에서 보이는 대부분의 문자들이 변수나 함수의 이름이기 때문입니다.  
변수의 이름만 잘 지어줘도 프로그램의 구조가 잘 보일 수 있습니다.

#### 변수, 함수, 구조체 명명법

개발자 사회에서는 변수, 함수, 구조체 등의 이름을 짓는데에 여러 종류의 규칙이 있습니다.  
그 중 주력인 두가지 네이밍 스타일을 소개합니다.  
```c
// snake_case
int game_board;
int get_winner_id;
struct game_user;
```
이름에서 단어들 사이에 언더바(_)를 넣는 규칙입니다. 문자는 모두 소문자로 씁니다.  
문자가뱀처럼 이어져있다고 해서 snake_case라고 부릅니다.  
c/c++ 에서 주로 사용합니다.  

```c
// camelCase
int gameBoard;
int getWinnerId;
struct GameUser;
```
단어들의 첫 문자를 대문자를 사용해서 구분하는 규칙입니다.  
대문자와 소문자가 번갈아가면서 나타난다고 해서 camel(낙타)case 라고 부릅니다.  
class나 struct의 첫 글자는 대문자를 사용하고 변수나 함수의 첫글자는 소문자를 사용합니다.  
자바에서 주로 사용하죠.  

추가적으로 상수의 네이밍 스타일도 두가지 정도 있습니다.  
```c
#define Student // 첫문자만 대문자로
#define STUDENT // 모두 대문자로
```

여러가지 스타일이 있다만 가장 중요한것은 한가지 스타일을 일관성있게 사용할 줄 아느냐 입니다.  
다른 사람과 협업하다보면 그때그때 스타일을 바꿔야 하는 경우가 많기 때문입니다.  
서로 다른 스타일이 섞이면 혼란스러운 코드가 됩니다.  
저는 일부러 두 가지 스타일을 모두 사용합니다. 자바를 사용할 때는 camelCase c언어를 사용할 떄는 snake_case를 사용하곤 합니다. 어는 한가지 스타일에 적응되어 습관이 되지 않게 하기 위해서입니다.  

#### 의도를 분명히 밝혀라

```c
int d; // 날짜
```
d를 딱 봤을 때 자기가 짰을 때는 알아볼 수 있을지 몰라도 다른사람이 봤을 때는 무슨 의미인지 알 수가 없습니다.  

```c
int day
```
변수에 이름을 붙일 때는 시간이 조금 걸리더라도 의미가 분명한 이름을 붙여주는 것이 좋습니다.  

다음은 학생관리 프로그램입니다.  
```c
#include <stdio.h>

typedef struct Student
{
	int id, status;
	char name[12];
}Student;

int main()
{
	Student arr[3] = { { 18101290,0,"inseo" }, { 123,1,"b" }, { 33,2,"c" } };

	for (int i = 0; i < 3; i++)
	{
		switch (arr[i].status)
		{
		case 0: 
			printf("%s님의 상태 = %s\n", arr[i].name, "재학");
			break;
		case 1:
			printf("%s님의 상태 = %s\n", arr[i].name, "휴학");
			break;
		case 2:
			printf("%s님의 상태 = %s\n", arr[i].name, "졸업");
			break;
		}
	}
}
```
여기서 구조체 멤버중 status의 값이 0, 1, 2가 될 수 있다는 것은 알겠는데. 한눈에 파악하기가 쉽지 않습니다. 0, 1, 2 그 자체에는 아무 의미도 없기 때문이지요.  
게다가 졸업을 1 휴학을 2 로 바꾸고 싶다고 하면 코드 전체에 있는 졸업의 의미를 가진 1과 휴학의 의미를 가진 2를 찾은 후에 그 값을 바꿔줘야 합니다. 너무나 번거로운 작업이 됩니다.  

0,1,2 같은 아무 의미 없는 값에 의미를 부여해주는 것이 바로 상수 입니다.  
다음 코드는 상수를 만들어 0에 재학, 1에 휴학, 2에 졸업이라는 의미를 부여해준 것입니다.  
```c
#include <stdio.h>

#define BEING 0
#define ABSENT 1
#define GRADUATE 2

typedef struct Student
{
	int id, status;
	char name[12];
}Student;

int main()
{
	Student arr[3] = { { 18101290,BEING,"inseo" }, { 123,ABSENT,"b" }, { 33,GRADUATE,"c" } };

	for (int i = 0; i < 3; i++)
	{
		switch (arr[i].status)
		{
		case BEING: 
			printf("%s님의 상태 = %s\n", arr[i].name, "재학");
			break;
		case ABSENT:
			printf("%s님의 상태 = %s\n", arr[i].name, "휴학");
			break;
		case GRADUATE:
			printf("%s님의 상태 = %s\n", arr[i].name, "졸업");
			break;
		}
	}
}
```

### 함수 작성법

C 프로그램은 기본 동작 단위가 함수이기 때문에 읽고 이해하기 쉬운 함수를 작성해야 합니다.

#### 작게 만들어라

함수는 최대한 작게 만드는 것이 좋습니다. 중복된 부분을 코드 전체에 중복된 부분을 빼내서 여러 함수를 만드는 것이 좋습니다. 

#### 한가지만 해라

함수는 한가지만 해야 합니다. 함수는 그 한가지만을 고려해야 하고 한가지만을 잘 해야 합니다.  

#### 함수의 인수

함수에서 이상적인 매개변수의 개수는 0개 입니다. 차선은 1개뿐인 경우이죠 하지만 C언어에서는 그게 힘든 경우가 많습니다.  

C언어는 프로그램의 구조가 크게 복잡해질 일이 없어서 프로그래밍 규칙에 대해서 할 말이 많지는 않습니다.  
어떻게 해야 코드가 논리적이고 읽기쉽게 될지 계속 고민하는 것이 중요한 것입니다.  

## GCC 안내

GCC는 Good Coding Challenge의 약자입니다. 지금까지 스터디의 성과를 확인하고 C언어로 개발을 경험해 보게 하고 또 최대한 부담은 덜어주고 싶어 고안한 과제입니다.  

예상치 못하게 스터디가 여러번 빠지게 돼서 과제를 하기에 애매한 기간이 되었습니다. 따라서 과제를 1, 2차 두개로 나누려 합니다. 과제의 확인은 온라인으로도 충분히 진행할 수 있으니 종강한 뒤에도 할 수 있을 것 같습니다. 2차 과제의 기간은 아직 미정입니다.  
1차 과제는 6월 8일 11시59분 까지 학기 초에 받았던 신입생 테스트 문제를 다시 풀고 드라이브에 올리는 것입니다. 이 때 오늘 배운 좋은 코드 작성법을 조금이나마 생각하고 작성하셨으면 좋겠습니다.  
2차 과제의 공지는 추후 하도록 하겠습니다.